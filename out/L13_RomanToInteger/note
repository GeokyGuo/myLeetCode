头的呢， s.startsWith(rom[j],i)，然后i的步长就是枚举值的长度  枚举值要有顺序，hashmap不满足，就把key和vaule分别做成一个数组1.有一个步长的思想， 组合中只会出现 一个字符 或两个字符的组合，那么 就让两个优先， 不满足就只进一步，满足就进两步！！
                                                                                                                                         2. 双指针 的思想， 用当前的值 与上一个值进行比较，发现小大 这种组合的异常，然后单独判断,减二倍
                                                                                                                                         3.好的点是想到了用hashmap,,其实这种单纯的匹配而非查找， 也可以用switch语句！！！   //  char[] chars = s.toCharArray(); 字符串可以转数组！！
                                                                                                                                         4.subString 是前闭后开

                                                                                                                                         步长的思想，还有一个解法： 代码中已经写的  是 把罗马字符串截取出来，看是否满足hashmap中的key
                                                                                                                                                                     另一个角度， 罗马字符串的某i位  是否是以某枚举值开