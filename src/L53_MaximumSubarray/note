对动态规划有了一点点认识，

https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/
https://leetcode-cn.com/problems/maximum-subarray/solution/xiang-xi-jie-du-dong-tai-gui-hua-de-shi-xian-yi-li/

思考状态与状态转移方程
本题中状态 是以i结尾的 往前连续的最大和，
所以转移方程就是  d[i] = max(d[i-1]+nums[i],nums[i]);

然后自己想了想，怎么统计最大连续时的  始末下标，
昨天的思绪特别乱，其实 本质还是去思考清楚 状态这个概念， di代表以i为结尾的连续最大和，因为i之前的是统计过的，
如果是 股票【121题】那个的话，就可以定义 di代表 以i为结尾的，【0，i-1】这个区间中出现的最小值，因为i之前的是统计过的， 这也是大O 可以是n 的原因
同样也可以去想 接雨水【42】那个题， 其实都是同一类问题，即当前元素向前（这个"前"是说已经统计过的元素），或者当前元素之前的的最大值或者最小值（可以算差值）--->也可以转化成差分求和

那么相应的也可以定义一个 xi 代表以i为结尾连续元素的  第一个元素的下标值。 每一个元素都知道自己往前推几个（即知道起始下标是谁）是连续最大的（即知道自己对应的最大值是多少），
然后最后的结果，不依赖每一个 xi 和di， 即可以把xi和di简化成 一个或几个变量

===============================================================
通常我们遍历子串或者子序列有三种遍历方式
以某个节点为开头的所有子序列: 如 [a] [a, b], [ a, b, c] ... 再从以 b为开头的子序列开始遍历[b] [b, c] ..
根据子序列的长度为标杆, 如先遍历出子序列长度为 1 的子序列, 在遍历出长度为 2 的 等等
以子序列的结束节点为基准, 先遍历出以某个节点为结束的所有子序列, 因为每个节点都可能会是子序列的结束节点,因此要遍历下整个序列, 如: 以b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]
第一种遍历方式通常用于暴力解法, 第二种遍历方式 leetcode (5. 最长回文子串 ) 中的解法就用到了

第三种遍历方式 因为可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式, 如 背包问题, 最大公共子串 , 这里的动态规划解法也是以 先遍历出 以某个节点为结束节点的所有子序列 的思路

